)]}'
{"version": 3, "sources": ["/web/static/src/polyfills/object.js", "/web/static/src/polyfills/array.js", "/web/static/src/module_loader.js", "/web/static/src/session.js", "/web/static/src/core/browser/cookie.js", "/web/static/src/legacy/js/core/minimal_dom.js", "/web/static/src/legacy/js/public/lazyloader.js", "/web_editor/static/src/js/frontend/loader_loading.js"], "mappings": "AAAA;;;;;AAAA;AACA;AACA;AACA;ACHA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/LA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;ACJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3IA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3LA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["if (!Object.hasOwn) {\n    Object.hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n}\n", "if (!Array.prototype.at) {\n    Object.defineProperty(Array.prototype, \"at\", {\n        enumerable: false,\n        value: function (index) {\n            if (index >= 0) {\n                return this[index];\n            }\n            return this[this.length + index];\n        }\n    });\n}\n", "/**\n *------------------------------------------------------------------------------\n * Odoo Web Boostrap Code\n *------------------------------------------------------------------------------\n */\n(function () {\n    \"use strict\";\n\n    class ModuleLoader {\n        /** @type {Map<string,{fn: Function, deps: string[]}>} mapping name => deps/fn */\n        factories = new Map();\n        /** @type {Set<string>} names of modules waiting to be started */\n        jobs = new Set();\n        /** @type {Set<string>} names of failed modules */\n        failed = new Set();\n\n        /** @type {Map<string,any>} mapping name => value */\n        modules = new Map();\n\n        bus = new EventTarget();\n\n        checkErrorProm = null;\n\n        /**\n         * @param {string} name\n         * @param {string[]} deps\n         * @param {Function} factory\n         */\n        define(name, deps, factory) {\n            if (typeof name !== \"string\") {\n                throw new Error(`Invalid name definition: ${name} (should be a string)\"`);\n            }\n            if (!(deps instanceof Array)) {\n                throw new Error(`Dependencies should be defined by an array: ${deps}`);\n            }\n            if (typeof factory !== \"function\") {\n                throw new Error(`Factory should be defined by a function ${factory}`);\n            }\n            if (!this.factories.has(name)) {\n                this.factories.set(name, {\n                    deps,\n                    fn: factory,\n                    ignoreMissingDeps: globalThis.__odooIgnoreMissingDependencies,\n                });\n                this.addJob(name);\n                this.checkErrorProm ||= Promise.resolve().then(() => {\n                    this.checkAndReportErrors();\n                    this.checkErrorProm = null;\n                });\n            }\n        }\n\n        addJob(name) {\n            this.jobs.add(name);\n            this.startModules();\n        }\n\n        findJob() {\n            for (const job of this.jobs) {\n                if (this.factories.get(job).deps.every((dep) => this.modules.has(dep))) {\n                    return job;\n                }\n            }\n            return null;\n        }\n\n        startModules() {\n            let job;\n            while ((job = this.findJob())) {\n                this.startModule(job);\n            }\n        }\n\n        startModule(name) {\n            const require = (name) => this.modules.get(name);\n            this.jobs.delete(name);\n            const factory = this.factories.get(name);\n            let value = null;\n            try {\n                value = factory.fn(require);\n            } catch (error) {\n                this.failed.add(name);\n                throw new Error(`Error while loading \"${name}\":\\n${error}`);\n            }\n            this.modules.set(name, value);\n            this.bus.dispatchEvent(\n                new CustomEvent(\"module-started\", { detail: { moduleName: name, module: value } })\n            );\n        }\n\n        findErrors() {\n            // cycle detection\n            const dependencyGraph = new Map();\n            for (const job of this.jobs) {\n                dependencyGraph.set(job, this.factories.get(job).deps);\n            }\n            function visitJobs(jobs, visited = new Set()) {\n                for (const job of jobs) {\n                    const result = visitJob(job, visited);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return null;\n            }\n\n            function visitJob(job, visited) {\n                if (visited.has(job)) {\n                    const jobs = Array.from(visited).concat([job]);\n                    const index = jobs.indexOf(job);\n                    return jobs\n                        .slice(index)\n                        .map((j) => `\"${j}\"`)\n                        .join(\" => \");\n                }\n                const deps = dependencyGraph.get(job);\n                return deps ? visitJobs(deps, new Set(visited).add(job)) : null;\n            }\n\n            // missing dependencies\n            const missing = new Set();\n            for (const job of this.jobs) {\n                const factory = this.factories.get(job);\n                if (factory.ignoreMissingDeps) {\n                    continue;\n                }\n                for (const dep of factory.deps) {\n                    if (!this.factories.has(dep)) {\n                        missing.add(dep);\n                    }\n                }\n            }\n\n            return {\n                failed: [...this.failed],\n                cycle: visitJobs(this.jobs),\n                missing: [...missing],\n                unloaded: [...this.jobs].filter((j) => !this.factories.get(j).ignoreMissingDeps),\n            };\n        }\n\n        async checkAndReportErrors() {\n            const { failed, cycle, missing, unloaded } = this.findErrors();\n            if (!failed.length && !unloaded.length) {\n                return;\n            }\n\n            const style = document.createElement(\"style\");\n            style.textContent = `\n                body::before {\n                    font-weight: bold;\n                    content: \"An error occurred while loading javascript modules, you may find more information in the devtools console\";\n                    position: fixed;\n                    left: 0;\n                    bottom: 0;\n                    z-index: 100000000000;\n                    background-color: #C00;\n                    color: #DDD;\n                }\n            `;\n\n            document.head.appendChild(style);\n            if (failed.length) {\n                console.error(\"The following modules failed to load because of an error:\", failed)\n            }\n            if (missing) {\n                console.error(\"The following modules are needed by other modules but have not been defined, they may not be present in the correct asset bundle:\", missing);\n            }\n            if (cycle) {\n                console.error(\"The following modules could not be loaded because they form a dependency cycle:\", cycle);\n            }\n            if (unloaded) {\n                console.error(\"The following modules could not be loaded because they have unmet dependencies, this is a secondary error which is likely caused by one of the above problems:\", unloaded);\n            }\n        }\n    }\n\n    if (!globalThis.odoo) {\n        globalThis.odoo = {};\n    }\n    const odoo = globalThis.odoo;\n    if (odoo.debug && !new URLSearchParams(location.search).has(\"debug\")) {\n        // remove debug mode if not explicitely set in url\n        odoo.debug = \"\";\n    }\n\n    const loader = new ModuleLoader();\n    odoo.define = loader.define.bind(loader);\n\n    odoo.loader = loader;\n})();\n", "/** @odoo-module **/\n\nexport const session = odoo.__session_info__ || {};\ndelete odoo.__session_info__;\n", "/** @odoo-module **/\n\n/**\n * Utils to make use of document.cookie\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\n * As recommended, storage should not be done by the cookie\n * but with localStorage/sessionStorage\n */\n\nconst COOKIE_TTL = 24 * 60 * 60 * 365;\n\nexport const cookie = {\n    get _cookieMonster() {\n        return document.cookie;\n    },\n    set _cookieMonster(value) {\n        document.cookie = value;\n    },\n    get(str) {\n        const parts = this._cookieMonster.split(\"; \");\n        for (const part of parts) {\n            const [key, value] = part.split(/=(.*)/);\n            if (key === str) {\n                return value || \"\";\n            }\n        }\n    },\n    set(key, value, ttl = COOKIE_TTL) {\n        let fullCookie = [];\n        if (value !== undefined) {\n            fullCookie.push(`${key}=${value}`);\n        }\n        fullCookie = fullCookie.concat([\"path=/\", `max-age=${ttl}`]);\n        this._cookieMonster = fullCookie.join(\"; \");\n    },\n    delete(key) {\n        this.set(key, \"kill\", 0);\n    },\n};\n", "/** @odoo-module **/\n\nexport const DEBOUNCE = 400;\nexport const BUTTON_HANDLER_SELECTOR = 'a, button, input[type=\"submit\"], input[type=\"button\"], .btn';\n\n/**\n * Protects a function which is to be used as a handler by preventing its\n * execution for the duration of a previous call to it (including async\n * parts of that call).\n *\n * Limitation: as the handler is ignored during async actions,\n * the 'preventDefault' or 'stopPropagation' calls it may want to do\n * will be ignored too. Using the 'preventDefault' and 'stopPropagation'\n * arguments solves that problem.\n *\n * @param {function} fct\n *      The function which is to be used as a handler. If a promise\n *      is returned, it is used to determine when the handler's action is\n *      finished. Otherwise, the return is used as jQuery uses it.\n * @param {function|boolean} preventDefault\n * @param {function|boolean} stopPropagation\n */\nexport function makeAsyncHandler(fct, preventDefault, stopPropagation) {\n    // TODO in master, add those as arguments.\n    const stopImmediatePropagation = this && this.__makeAsyncHandler_stopImmediatePropagation;\n\n    let pending = false;\n    function _isLocked() {\n        return pending;\n    }\n    function _lock() {\n        pending = true;\n    }\n    function _unlock() {\n        pending = false;\n    }\n    return function (ev) {\n        if (preventDefault === true || preventDefault && preventDefault()) {\n            ev.preventDefault();\n        }\n        if (stopPropagation === true || stopPropagation && stopPropagation()) {\n            ev.stopPropagation();\n        }\n        if (stopImmediatePropagation === true || stopImmediatePropagation && stopImmediatePropagation()) {\n            ev.stopImmediatePropagation();\n        }\n\n        if (_isLocked()) {\n            // If a previous call to this handler is still pending, ignore\n            // the new call.\n            return;\n        }\n\n        _lock();\n        const result = fct.apply(this, arguments);\n        Promise.resolve(result).finally(_unlock);\n        return result;\n    };\n}\n\n/**\n * Creates a debounced version of a function to be used as a button click\n * handler. Also improves the handler to disable the button for the time of\n * the debounce and/or the time of the async actions it performs.\n *\n * Limitation: if two handlers are put on the same button, the button will\n * become enabled again once any handler's action finishes (multiple click\n * handlers should however not be bound to the same button).\n *\n * @param {function} fct\n *      The function which is to be used as a button click handler. If a\n *      promise is returned, it is used to determine when the button can be\n *      re-enabled. Otherwise, the return is used as jQuery uses it.\n */\nexport function makeButtonHandler(fct) {\n    // TODO in master, add those as arguments. Even though buttons are probably\n    // blocked by the o_website_btn_loading and related classes, it is not\n    // necessarily true for all event types.\n    const preventDefault = this && this.__makeButtonHandler_preventDefault;\n    const stopPropagation = this && this.__makeButtonHandler_stopPropagation;\n    const stopImmediatePropagation = this && this.__makeButtonHandler_stopImmediatePropagation;\n\n    // Fallback: if the final handler is not bound to a button, at least\n    // make it an async handler (also handles the case where some events\n    // might ignore the disabled state of the button).\n    fct = makeAsyncHandler.call({\n        '__makeAsyncHandler_stopImmediatePropagation': stopImmediatePropagation,\n    }, fct, preventDefault, stopPropagation);\n\n    return function (ev) {\n        const result = fct.apply(this, arguments);\n\n        const buttonEl = ev.target && ev.target.closest && ev.target.closest(BUTTON_HANDLER_SELECTOR);\n        if (!(buttonEl instanceof HTMLElement)) {\n            return result;\n        }\n\n        // Disable the button for the duration of the handler's action\n        // or at least for the duration of the click debounce. This makes\n        // a 'real' debounce creation useless. Also, during the debouncing\n        // part, the button is disabled without any visual effect.\n        buttonEl.classList.add('pe-none');\n        Promise.resolve(DEBOUNCE && new Promise(r => setTimeout(r, DEBOUNCE)))\n            .then(function () {\n                buttonEl.classList.remove('pe-none');\n                const restore = addButtonLoadingEffect(buttonEl);\n                return Promise.resolve(result).then(restore, restore);\n            });\n\n        return result;\n    };\n}\n\n/**\n * Gives the button a loading effect by disabling it and adding a `fa`\n * spinner icon.\n * The existing button `fa` icons will be hidden through css.\n *\n * @param {HTMLElement} btnEl - the button to disable/load\n * @return {function} a callback function that will restore the button\n *         initial state\n */\nexport function addButtonLoadingEffect(btnEl) {\n    if (!(btnEl instanceof HTMLElement)) {\n        return () => {};\n    }\n    // Note that pe-none is used alongside \"disabled\" so that the behavior is\n    // the same on links not using the \"btn\" class -> pointer-events disabled.\n    btnEl.classList.add('o_website_btn_loading', 'disabled', 'pe-none');\n    btnEl.disabled = true;\n    const loaderEl = document.createElement('span');\n    loaderEl.classList.add('fa', 'fa-refresh', 'fa-spin', 'me-2');\n    btnEl.prepend(loaderEl);\n    return () => {\n        btnEl.classList.remove('o_website_btn_loading', 'disabled', 'pe-none');\n        btnEl.disabled = false;\n        loaderEl.remove();\n    };\n}\n", "/** @odoo-module **/\n\nimport {\n    BUTTON_HANDLER_SELECTOR,\n    makeAsyncHandler,\n    makeButtonHandler,\n} from '@web/legacy/js/core/minimal_dom';\n\n// Track when all JS files have been lazy loaded. Will allow to unblock the\n// related DOM sections when the whole JS have been loaded and executed.\nlet allScriptsLoadedResolve = null;\nconst _allScriptsLoaded = new Promise(resolve => {\n    allScriptsLoadedResolve = resolve;\n}).then(stopWaitingLazy);\n\nconst retriggeringWaitingProms = [];\n/**\n * Function to use as an event handler to replay the incoming event after the\n * whole lazy JS has been loaded. Note that blocking the incoming event is left\n * up to the caller (i.e. a potential wrapper, @see waitLazy).\n *\n * @param {Event} ev\n * @returns {Promise}\n */\nasync function waitForLazyAndRetrigger(ev) {\n    // Wait for the lazy JS to be loaded before re-triggering the event.\n    const targetEl = ev.target;\n    await _allScriptsLoaded;\n    // Loaded scripts were able to add a delay to wait for before re-triggering\n    // events: we wait for it here.\n    await Promise.all(retriggeringWaitingProms);\n\n    // At the end of the current execution queue, retrigger the event. Note that\n    // the event is reconstructed: this is necessary in some cases, e.g. submit\n    // buttons. Probably because the event was originally defaultPrevented.\n    setTimeout(() => {\n        // Extra safety check: the element might have been removed from the DOM\n        if (targetEl.isConnected) {\n            targetEl.dispatchEvent(new ev.constructor(ev.type, ev));\n        }\n    }, 0);\n}\n\nconst loadingEffectHandlers = [];\n/**\n * Adds the given event listener and saves it for later removal.\n *\n * @param {HTMLElement} el\n * @param {string} type\n * @param {Function} handler\n */\nfunction registerLoadingEffectHandler(el, type, handler) {\n    el.addEventListener(type, handler, {capture: true});\n    loadingEffectHandlers.push({el, type, handler});\n}\n\nlet waitingLazy = false;\n\n/**\n * Automatically adds a loading effect on clicked buttons (that were not marked\n * with a specific class). Once the whole JS has been loaded, the events will be\n * triggered again.\n *\n * For forms, we automatically prevent submit events (since can be triggered\n * without click on a button) but we do not retrigger them (could be duplicate\n * with re-trigger of a click on a submit button otherwise). However, submitting\n * a form in any way should most of the time simulate a click on the submit\n * button if any anyway.\n *\n * @todo This function used to consider the o_wait_lazy_js class. In master, the\n * uses of this classes should be removed in XML templates.\n * @see stopWaitingLazy\n */\nfunction waitLazy() {\n    if (waitingLazy) {\n        return;\n    }\n    waitingLazy = true;\n\n    document.body.classList.add('o_lazy_js_waiting');\n\n    // TODO should probably find the wrapwrap another way but in future versions\n    // the element will be gone anyway.\n    const mainEl = document.getElementById('wrapwrap') || document.body;\n    const loadingEffectButtonEls = [...mainEl.querySelectorAll(BUTTON_HANDLER_SELECTOR)]\n        // We target all buttons but...\n        .filter(el => {\n            // ... we allow to disable the effect by adding a specific class if\n            // needed. Note that if some non-lazy loaded code is adding an event\n            // handler on some buttons, it means that if they do not have that\n            // class, they will show a loading effect and not do anything until\n            // lazy JS is loaded anyway. This is not ideal, especially since\n            // this was added as a stable fix/imp, but this is a compromise: on\n            // next page visits, the cache should limit to effect of the lazy\n            // loading anyway.\n            return !el.classList.contains('o_no_wait_lazy_js')\n                // ... we also allow do not consider links with a href which is\n                // not \"#\". They could be linked to handlers that prevent their\n                // default behavior but we consider that following the link\n                // should still be relevant in that case.\n                && !(el.nodeName === 'A' && el.href && el.getAttribute('href') !== '#');\n        });\n    // Note: this is a limitation/a \"risk\" to only block and retrigger those\n    // specific event types.\n    const loadingEffectEventTypes = ['mouseover', 'mouseenter', 'mousedown', 'mouseup', 'click', 'mouseout', 'mouseleave'];\n    for (const buttonEl of loadingEffectButtonEls) {\n        for (const eventType of loadingEffectEventTypes) {\n            const loadingEffectHandler = eventType === 'click'\n                ? makeButtonHandler.call({\n                    '__makeButtonHandler_preventDefault': true,\n                    '__makeButtonHandler_stopImmediatePropagation': true,\n                }, waitForLazyAndRetrigger)\n                : makeAsyncHandler.call({\n                    '__makeAsyncHandler_stopImmediatePropagation': true,\n                }, waitForLazyAndRetrigger, true);\n            registerLoadingEffectHandler(buttonEl, eventType, loadingEffectHandler);\n        }\n    }\n\n    for (const formEl of document.querySelectorAll('form:not(.o_no_wait_lazy_js)')) {\n        registerLoadingEffectHandler(formEl, 'submit', ev => {\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n        });\n    }\n}\n/**\n * Undo what @see waitLazy did.\n */\nfunction stopWaitingLazy() {\n    if (!waitingLazy) {\n        return;\n    }\n    waitingLazy = false;\n\n    document.body.classList.remove('o_lazy_js_waiting');\n\n    for (const { el, type, handler } of loadingEffectHandlers) {\n        el.removeEventListener(type, handler, {capture: true});\n    }\n}\n\n// Start waiting for lazy loading as soon as the DOM is available\nif (document.readyState !== 'loading') {\n    waitLazy();\n} else {\n    document.addEventListener('DOMContentLoaded', function () {\n        waitLazy();\n    });\n}\n\n// As soon as the document is fully loaded, start loading the whole remaining JS\nif (document.readyState === 'complete') {\n    setTimeout(_loadScripts, 0);\n} else {\n    window.addEventListener('load', function () {\n        setTimeout(_loadScripts, 0);\n    });\n}\n\n/**\n * @param {DOMElement[]} scripts\n * @param {integer} index\n */\nfunction _loadScripts(scripts, index) {\n    if (scripts === undefined) {\n        scripts = document.querySelectorAll('script[data-src]');\n    }\n    if (index === undefined) {\n        index = 0;\n    }\n    if (index >= scripts.length) {\n        allScriptsLoadedResolve();\n        return;\n    }\n    const script = scripts[index];\n    script.addEventListener('load', _loadScripts.bind(this, scripts, index + 1));\n    script.setAttribute('defer', 'defer');\n    script.src = script.dataset.src;\n    script.removeAttribute('data-src');\n}\n\nexport default {\n    loadScripts: _loadScripts,\n    allScriptsLoaded: _allScriptsLoaded,\n    registerPageReadinessDelay: retriggeringWaitingProms.push.bind(retriggeringWaitingProms),\n};\n", "(function () {\n'use strict';\n\n/**\n * This file makes sure textarea elements with a specific editor class are\n * tweaked as soon as the DOM is ready so that they appear to be loading.\n *\n * They must then be loaded using standard Odoo modules system. In particular,\n * @see @web_editor/js/frontend/loadWysiwygFromTextarea\n */\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Standard loop for better browser support\n    var textareaEls = document.querySelectorAll('textarea.o_wysiwyg_loader');\n    for (var i = 0; i < textareaEls.length; i++) {\n        var textarea = textareaEls[i];\n        var wrapper = document.createElement('div');\n        wrapper.classList.add('position-relative', 'o_wysiwyg_textarea_wrapper');\n\n        var loadingElement = document.createElement('div');\n        loadingElement.classList.add('o_wysiwyg_loading');\n        var loadingIcon = document.createElement('i');\n        loadingIcon.classList.add('text-600', 'text-center',\n            'fa', 'fa-circle-o-notch', 'fa-spin', 'fa-2x');\n        loadingElement.appendChild(loadingIcon);\n        wrapper.appendChild(loadingElement);\n\n        textarea.parentNode.insertBefore(wrapper, textarea);\n        wrapper.insertBefore(textarea, loadingElement);\n    }\n});\n\n})();\n"], "file": "/web/assets/5ec42d9/web.assets_frontend_minimal.js", "sourceRoot": "../../../"}